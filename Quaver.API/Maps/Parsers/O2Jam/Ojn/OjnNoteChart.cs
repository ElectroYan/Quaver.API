using Quaver.API.Maps.Parsers.O2Jam.EventPackages;
using Quaver.API.Maps.Structures;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace Quaver.API.Maps.Parsers.O2Jam
{
    /// <summary>
    ///     One of the three difficulties contained in the .ojn file.
    ///     
    /// </summary>
    /// <remarks>
    ///     Most of the values can be edited by hand or by an external program, so relying on
    ///     counts provided by it is not a good idea.
    /// </remarks>
    public class OjnNoteChart
    {
        /// <summary>
        ///     The difficulty of the chart, set by the .ojn containing it
        /// </summary>
        public O2JamDifficulty Difficulty;

        /// <summary>
        ///     The level of the chart, set by the .ojn containing it.
        /// </summary>
        /// <remarks>
        ///     Usually auto-generated by the chart editor, but can be modified by hand in the .ojn file.
        /// </remarks>
        public int Level { get; set; }

        /// <summary>
        ///     The note count of the, set by the .ojn containing it. This also considers autoplay-notes
        ///     and long note releases/tails to be counted as well.
        /// </summary>
        /// <remarks>
        ///     This might not represent the actual note count, since, just like all of the level
        ///     and all other counts in this map, this can be modified by hand in the .ojn file.
        /// </remarks>
        public int NoteCount { get; set; }

        /// <summary>
        ///     The note count of the, set by the .ojn containing it. Unlike NoteCount, this does not consider
        ///     autoplay-notes, but does consider long note releases/tails.
        /// </summary>
        /// <remarks>
        ///     Can be modified by hand in the .ojn file.
        /// </remarks>
        public int PlayableNoteCount { get; set; }

        /// <summary>
        ///     The number of measures a specific difficulty contains. This can vary over different difficulties.
        /// </summary>
        /// <remarks>
        ///     Can be modified by hand in the .ojn file.
        /// </remarks>
        public int MeasureCount { get; set; }

        /// <summary>
        ///     The number of main packages a specific difficulty contains. This can vary over different difficulties.
        /// </summary>
        /// <remarks>
        ///     Can be modified by hand in the .ojn file.
        /// </remarks>
        public int MainPackageCount { get; set; }

        /// <summary>
        ///     The duration of the difficulty in seconds. This can vary over different difficulties.
        /// </summary>
        /// <remarks>
        ///     Can be modified by hand in the .ojn file.
        /// </remarks>
        public int Duration { get; set; }

        /// <summary>
        ///     The byte offset of the first main package in the respective difficulty in the .ojn binary file.
        /// </summary>
        public int StartingNoteByteOffset { get; set; }

        /// <summary>
        ///     All main packages contained in a specific difficulty. A main package considers a measure of BPM/Note/Measurement events.
        /// </summary>
        public List<O2JamMainPackage> MainPackages { get; set; }

        /// <summary>
        ///     Notes aconverted into a helper struct, which helps with converting the measure/subdivision system to milliseconds later on.
        /// </summary>
        public List<O2JamNote> Notes;

        /// <summary>
        ///     BPM changes aconverted into a helper struct, which helps with converting the measure/subdivision system to milliseconds later on.
        /// </summary>
        public List<O2JamBpm> BpmChanges;

        /// <summary>
        ///     Nearly all O2Jam editors support 1/192, which is the smallest subdivision currently used for all maps.
        ///     192 covers all common snaps, since the divisors are 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 192.
        ///     We use that to our advantage, by converting all measure/subdivision of all notes to a system of 192
        ///     per measure. This makes it easier to convert measures/subdivisions to milliseconds later on.
        /// </summary>
        public const int MAX_SNAP_DIVISOR = 192;

        public OjnNoteChart(O2JamDifficulty difficulty, int level, int noteCount, int playableNoteCount, int measureCount, int packageCount, int duration, int startingNoteOffset, List<O2JamMainPackage> packages)
        {
            Difficulty = difficulty;
            Level = level;
            NoteCount = noteCount;
            PlayableNoteCount = playableNoteCount;
            MeasureCount = measureCount;
            MainPackageCount = packageCount;
            Duration = duration;
            StartingNoteByteOffset = startingNoteOffset;
            MainPackages = packages;
        }

        /// <summary>
        ///     If the difficulty is actually valid.
        /// </summary>
        /// <returns></returns>
        public bool IsValid()
        {
            var packageCountOk = MainPackageCount == MainPackages.Count;

            // Autoplay samples (channel 9-22) are ignored, so the count is going to be 0
            var eventCountsOk = MainPackages.TrueForAll(
                p =>
                    p.EventCount == p.EventPackages.Count
                    || (p.Channel >= 9 && p.EventPackages.Count == 0)
            );

            var noteCountOk = GetActualPlayableNoteCountPerLane().Sum() == PlayableNoteCount;

            return packageCountOk && eventCountsOk && noteCountOk;
        }

        /// <summary>
        ///     Converts a level number to a readable string
        /// </summary>
        /// <remarks>
        ///     The level is padded to make searching for single/double digit levels easier.
        ///     The length is 3, since no chart can realistically exceed 1000.
        ///     Compare:
        ///         - "Lv. 1" matches Lv. 1, 12, 51, 410
        ///         - "Lv. 001" matches Lv. 001 and nothing else
        /// </remarks>
        /// <returns></returns>
        public string LevelToString() => $"Lv. {Level.ToString().PadLeft(3, '0')}";

        /// <summary>
        ///     The note count in the provided file could be edited or incorrect,
        ///     so this returns the true note count, regardless of what's provided in the .ojn file
        /// </summary>
        /// <returns>An array of all note counts in their respective lanes (0 = lane 1, 1 = lane 2...)</returns>
        public int[] GetActualPlayableNoteCountPerLane()
        {
            var noteCountArray = new int[7];

            foreach (var mainPackage in MainPackages)
                if (mainPackage.Channel >= 2 && mainPackage.Channel <= 8) // is lane
                    foreach (var eventPackage in mainPackage.EventPackages) // foreach note
                        if (eventPackage.IsNonZero())
                            noteCountArray[mainPackage.Channel - 2]++;

            return noteCountArray;
        }

        /// <summary>
        ///     The measure count in the provided file could be edited or incorrect,
        ///     so this returns the true measure count, regardless of what's provided in the .ojn file
        /// </summary>
        /// <returns>The maximum measure of the provided .ojn file</returns>
        public int GetActualMeasureCount() => MainPackages.Select(mainPackage => mainPackage.Measure).Max();

        /// <summary>
        ///     Nearly all O2Jam editors support 1/192, which is the smallest subdivision currently used for all maps.
        ///     192 covers all common snaps, since the divisors are 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 192.
        ///     We use that to our advantage, by converting all measure/subdivision of all notes to a system of 192
        ///     per measure. This makes it easier to convert measures/subdivisions to milliseconds later on.
        /// </summary>
        public void ConvertHitObjectsAndBpmsToHelperStructs()
        {
            Notes = new List<O2JamNote>();
            BpmChanges = new List<O2JamBpm>();
            foreach (var mainPackage in MainPackages)
            {
                var eventPackageNumber = 0;
                foreach (var eventPackage in mainPackage.EventPackages)
                {
                    if (eventPackage.IsNonZero())
                    {
                        var snapPosition = mainPackage.Measure * MAX_SNAP_DIVISOR + eventPackageNumber * MAX_SNAP_DIVISOR / mainPackage.EventPackages.Count();
                        switch (eventPackage)
                        {
                            case O2JamBpmEventPackage bpmEvent:
                                BpmChanges.Add(new O2JamBpm
                                {
                                    SnapPosition = snapPosition,
                                    BpmValue = bpmEvent.Bpm
                                });
                                break;
                            case O2JamNoteEventPackage noteEvent:
                                Notes.Add(new O2JamNote
                                {
                                    SnapPosition = snapPosition,
                                    Lane = mainPackage.Channel - 1,
                                    NoteType = noteEvent.NoteType,
                                    SampleIndex = noteEvent.SampleIndex
                                });
                                break;
                            default:
                                break;
                        }
                    }

                    eventPackageNumber++;
                }
            }

            Notes.OrderBy(x => x.SnapPosition);
            BpmChanges.OrderBy(x => x.SnapPosition);
        }

        /// <summary>
        ///     Converts all measure/subdivision times of notes/BPM changes to milliseconds.
        /// </summary>
        /// <remarks>
        ///     1BPM (beats per minute) means that a total of
        ///         1beat/min * 1min/60s * 1measure/4beats = 1/240 measures per second
        ///     pass.
        ///     
        ///     Since all note/BPM positions are now given in the system of 192 per measure, we can consider following:
        ///         1BPM = 1measure/240s * 192subdivisions/1measure = 4subdivisions/5s = 0.8 divisions/s
        ///     This is how we infer the constant of 0.8 used in this method.
        ///
        ///     This method relies on the notes and BPM changes being sorted by time.
        ///     It also ignores the measurement event, since it is very rarely used (only one file is known).
        /// </remarks>
        public void CalculateTimeOffsets()
        {
            ConvertHitObjectsAndBpmsToHelperStructs();

            const float DIVISIONS_PER_SECOND = 0.8f;
            var referenceTime = TimeSpan.Zero;
            var bpmIndex = 0;

            for (var i = 0; i < Notes.Count(); i++)
            {
                var note = Notes[i];
                while (bpmIndex + 1 < BpmChanges.Count() && note.SnapPosition > BpmChanges[bpmIndex + 1].SnapPosition)
                {
                    referenceTime += TimeSpan.FromSeconds(
                        (BpmChanges[bpmIndex + 1].SnapPosition - BpmChanges[bpmIndex].SnapPosition)
                        / (BpmChanges[bpmIndex].BpmValue * DIVISIONS_PER_SECOND)
                    );
                    bpmIndex++;
                    var bpm = BpmChanges[bpmIndex];
                    bpm.Time = referenceTime;
                    BpmChanges[bpmIndex] = bpm;
                }

                note.Time = TimeSpan.FromSeconds(
                    (note.SnapPosition - BpmChanges[bpmIndex].SnapPosition)
                    / (BpmChanges[bpmIndex].BpmValue * DIVISIONS_PER_SECOND)
                ) + referenceTime;

                Notes[i] = note;
            }
        }

        /// <summary>
        ///     Adds the notes and BPM changes to the provided Qua object.
        /// </summary>
        /// <param name="qua"></param>
        public void AddHitObjectsAndTimingPointsToQua(Qua qua)
        {
            CalculateTimeOffsets();
            foreach (var bpm in BpmChanges)
            {
                qua.TimingPoints.Add(new TimingPointInfo()
                {
                    Bpm = bpm.BpmValue,
                    StartTime = (float)bpm.Time.TotalMilliseconds
                });
            }

            foreach (var note in Notes)
            {
                var time = (int)Math.Round(note.Time.TotalMilliseconds, MidpointRounding.AwayFromZero);
                switch (note.NoteType)
                {
                    /*
                     * The reason normal notes and long note (LN) starts are handled the same, is because
                     * the LN end event *should* always happen after a LN start in the same lane.
                     * 
                     * This also covers the case, when the amount of LN starts and ends are different.
                     *     - If a LN end follows an LN end, the LN is simply extended.
                     *     - If a LN start follows an LN start, the LN start is simply shortened.
                     *     - If a LN start is missing an LN end at the end, the LN stays a normal note.
                     *
                     * Oppose this to the way of giving a LN start a unique value (for example int.MinValue)
                     * and use that as a reference for the LN end to find the corresponding LN start:
                     *     - If a LN start is missing an LN end at the end, the end time of that note stays int.MinValue,
                     *       which can have unpredictable outcomes.
                     */
                    case O2JamNoteType.NormalNote:
                    case O2JamNoteType.StartLongNote:
                        qua.HitObjects.Add(new HitObjectInfo
                        {
                            StartTime = time,
                            Lane = note.Lane
                        });
                        break;

                    case O2JamNoteType.EndLongNote:
                        qua.HitObjects.FindLast(x => x.Lane == note.Lane).EndTime = time;
                        break;

                    case O2JamNoteType.BgmNote:
                        break;

                    default:
                        break;
                }
            }
        }

        /// <summary>
        ///     Helper struct for all notes, which helps with converting from measure/subdivisions
        ///     to millisecond values later on.
        /// </summary>
        public struct O2JamNote
        {
            public int SnapPosition; // in a 1/192 grid per measure
            public int Lane;
            public O2JamNoteType NoteType;
            public TimeSpan Time;
            public int SampleIndex;
        }

        /// <summary>
        ///     Helper struct for all BPM changes, which helps with converting from measure/subdivisions
        ///     to millisecond values later on.
        /// </summary>
        public struct O2JamBpm
        {
            public int SnapPosition; // in a 1/192 grid per measure
            public float BpmValue;
            public TimeSpan Time;
        }
    }
}
